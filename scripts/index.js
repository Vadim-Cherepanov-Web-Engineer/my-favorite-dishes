// Шаг 1. Общие функции для открытия и закрытия попапов:
function makePopup(universalPopup) { // Создаём универсальную функцию для открытия и закрытия всех попапов на сайте. Передаём функции аргумент "универсальный попап".
	const closeButtonPopup = universalPopup.querySelector (".popup__closed"); // Объявляем локальную переменную closeButtonPopup и присваиваем ей класс .popup__closed, содержащий стили для закрытия попапов, в том числе кнопку-крестик для закрытия попапа при нажатии на неё.
	const popup = { // Объявляем новую переменную popup, которая будет отвечать за открытие и закрытие попапов.
		open() { // Cоздаём функцию open (без аргументов), отвечающую за открытие попапов.
			universalPopup.classList.add("popup_opened"); // Аргументу universalPopup присваиваем класс .popup_opened, содержащий стили для открытия попапов.
			universalPopup.addEventListener("mousedown", onOverlayClick); // На аргумент universalPopup навешиваем обработчик события с типом события "нажатие мышью" и функцией-колбэком onOverlayClick, которая будет отвечать за закрытие попапов при клике на overlay (область сайта за пределами попапов).
			document.addEventListener("keydown", onKeyDown) // Также аргументу universalPopup навешиваем обработчик события с типом события "нажатие клавиши" и функцией-колбэком onKeyDown, которая будет отвечать за закрытие попапов при нажатии клавиши Esc.
			closeButtonPopup.addEventListener("click", onCloseButtonClick) // Переменной closeButtonPopup, содержащей стили для закрытия попапов, навешиваем обработчик события с типом события "клик мышью" и функцией-колбэком onCloseButtonClick, которая будет отвечать за закрытие попапов при нажатии на экране кнопки-крестика, которая закрывает попап.
		},
		close() { // Cоздаём функцию close (без аргументов), отвечающую за закрытие попапов.
			universalPopup.classList.remove("popup_opened"); // У аргумента universalPopup удаляем класс .popup_opened, содержащий стили для открытия попапов. Т.е. обнуляем эти стили.
			universalPopup.removeEventListener("mousedown", onOverlayClick); // У аргумента universalPopup удаляем обработчик события, отвечающий за закрытие попапов при клике на overlay (область сайта за пределами попапов).
			document.removeEventListener("keydown", onKeyDown); // У аргумента universalPopup удаляем обработчик события, отвечающий за закрытие попапов при нажатии клавиши Esc.
			closeButtonPopup.removeEventListener("click", onCloseButtonClick) // У переменной closeButtonPopup, содержащей стили для закрытия попапов, удаляем обработчик события с типом события "клик мышью" и функцией-колбэком onCloseButtonClick, которая отвечает за закрытие попапов при нажатии на экране кнопки-крестика, которая закрывает попап.
		}
	};

	// Теперь отдельно создаём 3 функции-колбэка, указанные в коде выше:

	const onKeyDown = (event) => { // Объявляем функцию-колбэк onKeyDown, которая будет отвечать за закрытие попапов при нажатии клавиши Esc. В качестве аргумента передаём в функцию событие Х (event).
		if (event.key === "Escape") { // Вызываем у события X метод key (ключ) и говорим, что: "Если на событии сработает (строго равно) клавиша Escape, то...
			popup.close(); // ... тогда мы "связываемся" с переменной popup и в ней вызываем функцию close, которая отвечает за закрытие попапов.
		} // Т.е. если на событии срабатывает клавиша Escape, то событие получает сигнал о том, что нужно связаться с переменной popup и запустить в ней функцию close, с помощью которой нужно сразу закрыть попап, на котором и произошло данное событие.
	};

	const onCloseButtonClick = () => { // Объявляем функцию-колбэк onCloseButtonClick, которая будет отвечать за закрытие попапов при нажатии на экране кнопки-крестика, которая закрывает попап. Стили кнопки-крестика содержатся в классе .popup__closed, который присвоен переменной closeButtonPopup.
		popup.close(); // При нажатии/клике на кнопку-крестик сразу же срабатывает функция-колбэк onCloseButtonClick, которая связывается с переменной popup и запускает в ней функцию close, которая мгновенно закрывает попап.
	};

	const onOverlayClick = (event) => { // Объявляем функцию-колбэк onOverlayClick, которая будет отвечать за закрытие попапов при клике на overlay (область сайта за пределами попапов). В качестве аргумента передаём в функцию событие Х (event).
		if (event.target.classList.contains("popup_opened")) { // Вызываем у события метод target, который проверяет, что точно ли именно на этом конкретном попапе сработало имеено это произошедшее событие. Т.е. точно ли произошедшее событие click сработало именно на этом конкретном попапе, а не на остальных.
			// Далее метод target, в свою очередь используя для этого свойство classList с методом contains, проверяет, что точно ли именно данный попап использует сейчас класс .popup_opened. Т.е. точно ли во время клика на overlay нужно закрыть именно этот конкретный попап, которой открыт в данный момент, а не какой-нибудь другой.
			popup.close() // При клике на overlay сразу же срабатывает функция-колбэк onOverlayClick, которая связывается с переменной popup и запускает в ней функцию close, которая мгновенно закрывает попап.
		}
	}

	return popup; // В итоге аргумент universalPopup делает все свои дела (открывает или закрывает попап разными способами) и результатом своей деятельности возвращает функции makePopup переменную popup, которая либо откроет, либо закроет выбранный попап.
}

// Шаг 2. 1 попап - Редактирование профиля пользователя:

// Начинаем с объявления переменных (констант). Т.е. мы должны все классы попапов из HTML-разметки сделать DOM-элементами.
// Для этого нужно каждой переменной присвоить соответствующий класс с помощью метода querySelector.
// Это делается для того, чтобы мы могли работать с классами попапов как с DOM-элементами.

const editPopup = makePopup(document.querySelector(".profile-popup")); // Объявляем константу "редактировать Попап" и присваиваем ей нашу универсальную функцию makePopup для открытия и закрытия всех попапов на сайте.
// Но в качестве аргумента уже передаём не абстрактный universalPopup (как сверху), а именно конкретный попап "Редактирование профиля", с которым она и будет работать. Для этого указываем пустой "класс-маячок" .profile-popup, чтобы функция makePopup привязалась именно к этому попапу "Редактирование профиля".
const editButton = document.querySelector(".profile__edit-button"); // Объявляем константу "кнопка редактирования профиля" и присваиваем ей класс, содержащий стили для кнопки редактирования профиля.
const closeButton = document.querySelector(".popup__closed"); // Объявляем константу "кнопка закрытия попапа" и присваиваем ей класс, содержащий стили для кнопки закрытия попапа.
const titleInput = document.querySelector("#input-popup-title"); // Объявляем константу "заголовок инпута" и по id (идентификатору) с помощью метода querySelector связываемся с формой нашего попапа, чтобы получить доступ к инпуту "Ваше имя и фамилия".
const subtitleInput = document.querySelector("#input-popup-subtitle"); // Объявляем константу "подзаголовок инпута" и по id (идентификатору) с помощью метода querySelector связываемся с формой нашего попапа, чтобы получить доступ к инпуту "Статус в гастрономическом мире".
const titleProfile = document.querySelector(".profile__title"); // Объявляем константу "заголовок профиля" и присваиваем ей класс, отвечающий за отображение имени пользователя "Вадим Черепанов".
const subtitleProfile = document.querySelector(".profile__subtitle"); // Объявляем константу "подзаголовок профиля" и присваиваем ей класс, отвечающий за отображение статуса пользователя "Любитель вкусно поесть и сладко поспать!".
const editProfileForm = document.querySelector(".popup__form"); // Объявляем константу "Редактирование формы профиля" и присваиваем ей класс, отвечающий за стили формы в попапе.
const cards = document.querySelector(".cards"); // Объявляем константу "карточки"и присваиваем ей класс, описывающий стили и отображающий список карточек с блюдами.

// Создаём функцию, с помощью которой в попапе редактирования профиля будут отображаться текущие имя и статус пользователя.

editButton.addEventListener("click", function() { // На "кнопку редактирования профиля" навешиваем обработчик события с типом события "клик мышью" и с анонимной функцией-колбэком, которая при клике мышью на "кнопку редактирования профиля" выполняет по порядку следующие действия:
	editPopup.open(); // присваивает "кнопке редактирования профиля" функцию open(), которая открывает Попап редактирования профиля;
	titleInput.value = titleProfile.textContent; // Спец. атрибут value принимает текстовое значение из переменной "заголовок инпута", а именно из "Имени профиля" - "Вадим Черепанов" и передаёт его для отображения полю формы "Имя пользователя".
	// Затем с помощью свойства textContent присваивает это значение переменной titleProfile ("заголовок профиля" - имя пользователя) для того, чтобы в полях формы отобразились текущие значения из профиля пользователя. Т.е. текущие имя и статус, написанные в профиле, передались и отобразились в полях формы.
	subtitleInput.value = subtitleProfile.textContent; // Спец. атрибут value принимает текстовое значение из переменной "подзаголовок инпута", а именно из "Статус в гастрономическом мире" - "Любитель вкусов и ароматов";
	// Здесь процесс аналогичен верхней строчке кода. Т.е. свойство textContent является "переносчиком текста" из профиля пользователя, где он изначально написан, в соответствующие поля формы, где текст (имя пользователя и статус) и будет отображаться. Т.е.данные из профиля будут дублироваться в поля формы.
});

// Затем создаём функцию отправки формы, которая должна передать введённые в форму текстовые данные и передать их из Попапа редактирования профиля непосредственно самому профилю и, самое главное, сохранить новые данные. Чтобы при перезагрузке сайта новые данные не стёрлись.

function submitEditProfileForm (event) { // В качестве аргумента передаём функции отправки формы событие Х - event.
	event.preventDefault(); // Метод preventDefault отменяет стандартные действия браузера по умолчанию. В моём случае это делается для того, чтобы после заполнения формы она не отправлялась сразу же на сервер, а сначала успела произойти валидация формы (проверка правильности заполнения текстовых полей), и только после этого отправлять форму на сервер.
	// Т.е. метод preventDefault выступает в роли буфера защиты, который не даёт браузеру сразу отправить форму на сервер. Он приостанавливает это действие браузера. И  если валидация прошла успешно, то разрешает браузеру отправить форму, а если форма невалидна, то запрещает.
	// Здесь происходит зеркальный процесс 62 и 64 строк кода. Но если в тех строках с помощью метода textContent мы получали данные из профиля пользователя и отображали их в полях формы при её редактировании. То здесь наоборот: новые данные (имя и статус), введённые в форму, перезаписывают значения профиля и сохраняются.
	titleProfile.textContent = titleInput.value; // Имени пользователя в профиле присваивается новое имя, которое было введенно в поле формы. Т.е. значение имени в профиле при помощи метода textContent и атрибута value (хранящего новое введённое имя) перезаписывается и сохраняется на новое значение (новое имя), которое было введено в поле формы.
	subtitleProfile.textContent = subtitleInput.value; // Аналогичное действие происходит и полем "Статус пользователя".
	editPopup.close(); // После передачи данных из формы и сохранения их в профиле пользователя, попап нужно закрыть, т.к. он реализовал своё предназначение (редактирование профиля). Для этого попап (profile-popup) обращается к функции close(), которая и закрывает его тем способом, которых выберет пользователь (нажатием на кнопку "Сохранить для потомком", на клавишу Esc или на overlay).
} // На форму попапа навешивается обработчик события с типом события sumbit (означающего, что пользователь отправил форму на сервер) и функцией-колбэком, которая должна передать введённые в форму текстовые данные и передать их из Попапа редактирования профиля непосредственно самому профилю и, самое главное, сохранить новые данные. Чтобы при перезагрузке сайта новые данные не стёрлись.
editProfileForm.addEventListener("submit", submitEditProfileForm);

// Шаг 3. 2 попап - Добавление нового блюда:
const addPopup = makePopup(document.querySelector(".popup-type-new-dish")); // Объявляем константу "Попап добавления нового блюда" и присваиваем ей нашу универсальную функцию makePopup для открытия и закрытия всех попапов на сайте.
// Но в качестве аргумента уже передаём не абстрактный universalPopup (как сверху), а именно конкретный "Попап добавления нового блюда", с которым она и будет работать. Для этого указываем пустой "класс-маячок" .popup-type-new-dish, чтобы функция makePopup привязалась именно к этому попапу "Добавить новое блюдо".
const addButton = document.querySelector(".profile__add-button"); // Объявляем константу "кнопка добавления нового блюда" и присваиваем ей класс, содержащий стили для большой прямоугольной кнопки-крестика для добавления нового блюда.
addButton.addEventListener("click", function() { // На "кнопка добавления нового блюда" навешиваем обработчик события с типом события "клик мышью" и с анонимной функцией-колбэком, которая при клике мышью на "кнопку добавления нового блюда" выполняет следующее действие:
	addPopup.open(); // присваивает "кнопке добавления нового блюда" функцию open(), которая открывает Попап для добавления нового блюда.
});

const newCardForm = document.querySelector(".popup__form-add-card"); // Объявляем константу, которая преобразует форму для добавления нового блюда в DOM-элемент.
const nameInput = document.querySelector(".popup__input_type_name"); // Объявляем константу,которая превращает в DOM-элемент инпут названия блюда в форме.
const imageInput = document.querySelector(".popup__input_type_link-url"); // Объявляем константу,которая превращает в DOM-элемент ссылку на изображение блюда в форме.

newCardForm.addEventListener("submit", function(event) { // Форме попапа Добавления нового блюда навешиваем обработчик события с типом события "отправка формы" (это и есть событие event) и с функцией-колбэком, которая при клике мышью на "кнопку отправки формы" выполняет по порядку следующие действия:
	event.preventDefault(); // Метод preventDefault отменяет стандартные действия браузера по умолчанию. В моём случае это делается для того, чтобы после заполнения формы она не отправлялась сразу же на сервер, а сначала успела произойти валидация формы (проверка правильности заполнения текстовых полей), и только после этого отправлять форму на сервер.

	const card = createCard(nameInput.value, imageInput.value); // В константе card вызывается функция createCard, которая отвечает за создание карточек. Ей с помощью атрибута value передаются 2 аргумента: инпут с названием нового блюда и инпут с сссылкой на изображение нового блюда;
	cards.prepend(card); // Методом prepend вставляем новосозданную карточку в начало нашего списка карточек.

	newCardForm.reset(); // Метод HTMLFormElement.reset() сбрасывает/удаляет введённые значения в поля формы после их отправки на сервер. Чтобы при следующем открытии попапа поля формы были пусты и можно было сразу вводить новые данные.
	addPopup.close(); // После передачи данных из формы и создания из них новой карточки с блюдом, попап нужно закрыть, т.к. он реализовал своё предназначение (добавил карточку с новым блюдом). Для этого попап (popup-type-new-dish) обращается к функции close(), которая и закрывает его тем способом, которых выберет пользователь (нажатием на кнопку "Сохранить для потомком", на клавишу Esc или на overlay).
});

// Шаг 4. 3 попап - Раскрытие изображения блюда на весь экран:
const popupGallery = makePopup(document.querySelector(".popup_gallery")); // Объявляем константу "Попап раскрытия изображения блюда на весь экран" и присваиваем ей нашу универсальную функцию makePopup для открытия и закрытия всех попапов на сайте.
// Но в качестве аргумента уже передаём не абстрактный universalPopup (как сверху), а именно конкретный "Попап раскрытия изображения блюда на весь экран", с которым она и будет работать. Для этого указываем пустой "класс-маячок" .popup_gallery, чтобы функция makePopup привязалась именно к этому попапу.
const galleryImage = document.querySelector(".popup__image"); // Объявляем константу, которая будет отвечать за приём изображения блюда в попап.
const galleryFigcaption = document.querySelector(".popup__figcaption"); // Объявляем константу, которая будет отвечать за подпись к изображению блюда в попапе.

// Создаём функцию, которая будет отвечать за раскрытие изображения блюда на весь экран:
function openGallery(name, link) { // Создаём функцию. Передаём функции 2 аргумента. name отвечает за название блюда, а link - за ссылку на изображение блюда.
	galleryImage.setAttribute("src", link); // Устанавливаем для расширения изображения карточки атрибут src со значением link - ссылкой, по которой и будет загружаться изображение блюда.
	galleryImage.setAttribute("alt", name); // Также устанавливаем для расширения изображения карточки атрибут alt со значением name - названием блюда, расположенным под изображением.
	galleryFigcaption.innerText = name; // С помощью свойства innerText передаём текст (название блюда) из инпута формы в подпись снизу под карточкой с блюдом.
	popupGallery.open(); // После выполнения вышеописанных действий попап обращается к функции open, которая откроет изображение кликнутого блюда на весь экран.
};

// Шаг 5. Отрисовка списка карточек:

// Создаём функцию, которая будет отвечать за создание и отрисовку списка карточек:
function createCard(name, link) { // Передаём функции 2 аргумента. name отвечает за название блюда, а link - за ссылку на изображение блюда.
 // Создаём константу, которая преобразует каждую конкретную карточку из списка всех карточек в DOM-элемент. document.getElementById() возвращает ссылку на элемент card по его идентификатору.
	const card = document.getElementById("card").content.cloneNode(true); // Затем с помощью метода Node.cloneNode() возвращаем дубликат узла card, т.е. клонируем элемент card и получаем его точную копию, чтобы работать именно с копией, не затрагивая оригинал.

	// Далее создаём локальные константы для функции, которые преобразуют классы карточек в DOM-элементы.

	const cardLike = card.querySelector(".card__like"); // Константа отвечает за лайк карточек и содержит в стилях иконки изображений неактивного (прозрачного) и активного (чёрного) сердечек.
	const deleteIcon = card.querySelector(".card__delete-icon"); // Константа отвечает за удаление карточек и содержит в стидях иконку "корзины", при нажатии на которую будет удаляться карточка.
	const cardImage = card.querySelector(".card__image"); // Константа отвечает за отображение изображений блюд.
	const cardTitle = card.querySelector(".card__title"); // Константа отвечает за отображение названий блюд.

	cardImage.setAttribute("src", link); // Устанавливаем для изображения карточки атрибут src со значением link - ссылкой, по которой и будет загружаться изображение блюда.
	cardImage.setAttribute("alt", name); // Также устанавливаем для изображения карточки атрибут alt со значением name - названием блюда, расположенным под изображением.
	cardTitle.innerText = name; // С помощью свойства innerText передаём текст (название блюда) из инпута формы в саму новосозданную карточку.

	// Создаём функцию, отвественную за возможность лайка карточек:
	cardLike.addEventListener("click", function() { // На DOM-элемент cardLike, содержащий в себе стили для лайка карточек, навешиваем обработчик события с типом события события "клик мышью" и анонимной функцией-колбэком, которая при клике мышью на значок "сердечко" (лайк) производит следующие действия:
		cardLike.classList.toggle("card__like_active") // На DOM-элемент cardLike с помощью метода classList и его свойства toggle (переключатель) перкелючает/замещает неактивные класс лайка на активный. Т.е. в этот момент "неактивное прозрачное сердечко" заменяется на "активное чёрное сердечко" и происходит лайк карточки.
	});

	// Создаём функцию, ответственную за удаление старых и новых карточек:
	deleteIcon.addEventListener("click", function(event) { // На DOM-элемент deleteIcon, содержащий в себе класс с иконкой "корзины", при нажатии на которую будет удаляться карточка, навешиваем обработчик события с типом события "клик мышью" и функцией-колбэком с аргументом event - событием X, т.е. событием, которое мы ожидаем, что оно произойдёт на этой карточке.
		event.target.closest(".card").remove(); // Когда event - событие Х (клик мышью на иконку "корзины") произошёл, то теперь с помощью свойства target мы должны убедиться, что событие сработало именно на той карточке, по которой был сделан клик, а не по любой другой. Т.е. что именно на этой карточке, которую хотим удалить, была нажата иконка "корзины".
		// Метод closest ищет ближайший родительский элемент, подходящий под указанный CSS селектор. Т.е. closest ищет родителя (card) для дочернего элемента .card__delete-icon. Т.е. через дочерний класс, "как рыбу на крючок", он захватывает весь родитель card. И с помощью target понимая, что иконка "корзины" была нажата именно на этой карточке.
		// И с помощью спец. метода remove удаляет эту карточку! Т.е. происходит цепь событий: клик мышью на иконку "корзины" (событие event); затем target определяет, что точно ли именно на этой карточке был совершён клик; далее closest по дочернему элементу .card__delete-icon находит и захватывает его родителя card; и теперь захваченный элемент card удаляется из списка методом remove  и больше не отображается на сайте.
	});

	// Создаём функцию, ответственную за передачу изображения блюда из списка карточек в попап Раскрытия картинки на весь экран:
	cardImage.addEventListener("click", function() { // На изображение карточки вешаем обработчик события с типом события "клик мышью" и анонимной функцией-колбэком, которая активируется при клике мышью и выполняет:
		openGallery(name, link) // выполняет вызов функции openGallery и передаёт ей в качестве аргументов имя блюда и ссылку на его изображение для того, чтобы они отобразились в Попапе увеличения изображения.
	});

	return card; // в конце функция должна вернуть готовую карточку со всеми параметрами.
}

// Привязываем список карточек блюд к сайту:
initialCards.forEach((data) => { // С помощью метода перебора массивов forEach перебираем наш массив с карточками, сохраняя его в атрибуте data, и для каждого элемента массива (каждой карточки) выполняем следующие действия:
	const card = createCard(data.name, data.link); // Объявляем локальную переменную card и присавиваем ей функцию, которая создаёт новые карточки и в качестве аргументов передаём ей название и ссылку на изображение блюда, и сохраняем всё это в атрибуте data.
	cards.append(card); // Методом append вставляем новосозданную карточку в конец нашего списка карточек.
});